---
title: "Brad PT"
author: "Jason"
created: "16/03/2020"
modified: "3/17/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r ---> Libraries}
# library(readxl) # This is used to import data from excel
library(doBy)
library(lubridate)
library(psych)
library(corrplot)
library(colorspace)
library(ez)
library(Hmisc)
library(modelr)
# library(fuzzyjoin)
# library(reshape2)
library(varhandle)
library(multcomp)
library(car)
# library(lattice)
# library(Formula)
# library(Hmisc)
library(readr)
library(ggpubr)
library(skimr)
library(tidyverse)
library(reprex)
library(here)
here()
dr_here(show_reason = FALSE)


# library(ez) Not working for some reason March 17, 2020
# library(readr)		# ALREADY IN TIDYVERSE
# library(ggplot2)		# ALREADY IN TIDYVERSE
# library(dplyr) 		# ALREADY IN TIDYVERSE
```
```{r ---> data prep}
#		THIS SECTION PREPARED THE ORIGINAL DATA FOR SUBSEQUENT USE

#	This reads the files created by RedCap
# source('ImagingPsychometrics-BradPTConference_R_2020-03-16_1300.r')
# #		RENAME VARIABLE
# names(data)[names(data) == 'participant_id'] <- 'ID'
# # names(data)[names(data) == 'psqi_1']  <- 'psqi.bedtime'
# # names(data)[names(data) == 'psqi_1a.factor'] <- 'psqi.bt.sleep'
# # names(data)[names(data) == 'psqi_3'] <- 'psqi.waketime'
# # names(data)[names(data) == 'psqi_3a.factor'] <- 'psqi.wt.wake'
# 
# #		WRITE NEW DATASET
# write_csv(data, "PT_data_13042020.csv",
# 		  na = "NA", append = FALSE,
# 		  col_names = TRUE, quote_escape = "double")
# 
# 
# 
# data0 <- read.csv(url('https://raw.githubusercontent.com/BrainStormCenter/ASQ_pilot/master/ASQ_pain_pilot_2019_04_19_v2.csv'), header = TRUE)

```

```{r ---> Import data}
#		IMPORT DATA FROM GITHUB
data <- read.csv(url('https://raw.githubusercontent.com/BrainStormCenter/Brad_PT/master/PT_data_13042020.csv'), header = TRUE)
data <- as_tibble(data)
```

```{r ---> Clean data}
#		CLEANING AND PRESERVING ORIGINAL DATA
data %>% count(group)
dat1  <- filter(data, group != 0, group != "NA", data$bdi1 != "NA")
dat1$group.factor = factor(dat1$group,levels=c("1","2","3"))
levels(dat1$group.factor)=c("HC","CLBP","FM", na.rm = TRUE)

#		REPLACE HC McGILL TOTAL "NA" WITH 0
dat1$mcgill_total  <- coalesce(dat1$mcgill_total, 0L)

#		CLEAN ESS BY REMOVING "NA"
dat1   <- filter(dat1, ess_total != "NA")


dat1 %>% count(group.factor)
```



# PSQI DATASET
```{r ---> PSQI dataset}
#		PSQI DATA
# gather psqi variables into separate spreadsheet:
dat.psqi <- dat1[,c(1,425,769,
					  grep("pittsburgh", colnames(dat1)),
					  grep("psqi", colnames(dat1)))]
#grep("timestamp", colnames(dat.raw))

colnames(dat.psqi)
# label(dat.psqi)
# view(dat.psqi)

#	REORGANIZE VARIABLES
dat.psqi <- dat.psqi %>% select(1:7,43,everything()) 
dat.psqi <- dat.psqi %>% select(1:11,44,everything()) 
dat.psqi <- dat.psqi %>% select(1:14,45,everything()) 
dat.psqi <- dat.psqi %>% select(1:16,46,everything()) 
dat.psqi <- dat.psqi %>% select(1:18,47,everything())
dat.psqi <- dat.psqi %>% select(1:20,48,everything())
dat.psqi <- dat.psqi %>% select(1:22,49,everything())
dat.psqi <- dat.psqi %>% select(1:24,50,everything())
dat.psqi <- dat.psqi %>% select(1:26,51,everything())
dat.psqi <- dat.psqi %>% select(1:28,52,everything())
dat.psqi <- dat.psqi %>% select(1:30,53,everything())
dat.psqi <- dat.psqi %>% select(1:32,54,everything())
dat.psqi <- dat.psqi %>% select(1:35,55,everything())
dat.psqi <- dat.psqi %>% select(1:37,56,everything())
dat.psqi <- dat.psqi %>% select(1:39,57,everything())
dat.psqi <- dat.psqi %>% select(1:41,psqi_8b.factor,
								psqi_9, psqi_9.factor,
								everything())
dat.psqi <- dat.psqi %>% select(1:45,
								psqi_10.factor,
								psqi_10a, psqi_10a.factor,
								psqi_10b, psqi_10b.factor,
								psqi_10c, psqi_10c.factor,
								psqi_10d, psqi_10d.factor,
								psqi_10e, 
								psqi_10e1, psqi_10e1.factor,
								everything())

dat.psqi <- dat.psqi %>% select(1:2,group.factor,everything())

colnames(dat.psqi)

write.csv(dat.psqi, "PSQI_rawData_13April2020.csv", row.names = FALSE)

# ls()
```

```{r ---> chr to num}
dat.psqi$psqi_2 <- as.numeric(dat.psqi$psqi_2)
dat.psqi$psqi_4 <- as.numeric(dat.psqi$psqi_4)
dat.psqi$psqi_5a <- as.numeric(dat.psqi$psqi_5a)
dat.psqi$psqi_5b <- as.numeric(dat.psqi$psqi_5b)
dat.psqi$psqi_5c <- as.numeric(dat.psqi$psqi_5c)
dat.psqi$psqi_5d <- as.numeric(dat.psqi$psqi_5d)
dat.psqi$psqi_5e <- as.numeric(dat.psqi$psqi_5e)
dat.psqi$psqi_5f <- as.numeric(dat.psqi$psqi_5f)
dat.psqi$psqi_5g <- as.numeric(dat.psqi$psqi_5g)
dat.psqi$psqi_5h <- as.numeric(dat.psqi$psqi_5h)
dat.psqi$psqi_5i <- as.numeric(dat.psqi$psqi_5i)
dat.psqi$psqi_5othera <- as.numeric(dat.psqi$psqi_5othera)
dat.psqi$psqi_7 <- as.numeric(dat.psqi$psqi_7)
dat.psqi$psqi_8a <- as.numeric(dat.psqi$psqi_8a)

dat.psqi$psqi_9 <- as.numeric(dat.psqi$psqi_9)
dat.psqi$psqi_component1 <- as.numeric(dat.psqi$psqi_component1)


#		REPLACE "NA" WITH 0
dat.psqi$psqi_5othera <- dat.psqi$psqi_5othera %>% replace_na(0)


```

# PSQI SCORING
The global PSQI score is then calculated by totaling the seven component scores, providing an overall score ranging from 0 to 21, where lower scores denote a healthier sleep quality. 

```{r ---> Time in bed}
dat.psqi$bedtime  <- dat.psqi$psqi_1
dat.psqi$bt.sleep <- dat.psqi$psqi_1a.factor
dat.psqi$waketime <- dat.psqi$psqi_3
dat.psqi$wt.wake <- dat.psqi$psqi_3a.factor

#		FOR FORUM HELP VERSION #1
#		GOING TO SLEEP AND WAKING UP ON THE SAME DAY RESULTS IN 24+ HOURS
dat.psqi <- dat.psqi %>%
	mutate_all(.funs = as.character) %>%
	mutate_at(.vars = c("bt.sleep", "wt.wake"),
			  .funs = ~ gsub(pattern = ".",
			  			   replacement = "",
			  			   x = .x,
			  			   fixed = TRUE)) %>%
	mutate(Sleep = as.POSIXct(x = paste(bedtime, bt.sleep),
							  format = "%I:%M %p"),
		   Wake = as.POSIXct(x = paste(waketime, wt.wake),
		   				  format = "%I:%M %p") +
		   	as.difftime(tim = 1, units = "days"),
		   `Time in bed` = Wake - Sleep)

#		CRUDE FIX FOR THE 24+ HOUR ISSUE
dat.psqi$TIB  <- as.numeric(dat.psqi$`Time in bed`)
round(dat.psqi$TIB  <- if_else(dat.psqi$TIB < 24,
					  dat.psqi$TIB,
					  dat.psqi$TIB - 24), 2)


write.csv(dat.psqi, "PSQI_rawData_April2020_v1.csv", row.names = FALSE)

colnames(dat.psqi)

```

```{r ---> COMP 1}
#		COMPONENT 1 = QUESTION 9
dat.psqi$psqi_Comp1 <- dat.psqi$psqi_component1

#		SCORE QUESTION 1
# Component 1: Subjective sleep quality—question 9
# Response, Component Score to Q9 
# Very good, 0
# Fairly good, 1
# Fairly bad, 2
# Very bad, 3

dat.psqi <- dat.psqi %>% relocate(psqi_Comp1, .after = last_col())

```

```{r ---> COMP 2}
# Component 2: Sleep latency—questions 2 and 5a

dat.psqi$Q2 <- dat.psqi$psqi_2
dat.psqi$Q5a <- dat.psqi$psqi_5a

dat.psqi  <- dat.psqi %>%
	mutate(
		Q2score1 = case_when(
			Q2 <= 15 ~ 0,
			Q2 >= 16 & Q2 <= 30 ~ 1,
			Q2 >= 31 & Q2 <= 60 ~ 2,
			Q2 > 60 ~ 3,
			TRUE ~ as.numeric(Q2)
		)
	)

dat.psqi <- dat.psqi %>% 
	mutate(
		Q5aScore1 = case_when(
			Q5a == 1 ~ 0,
			Q5a == 2 ~ 1,
			Q5a == 3 ~ 2,
			Q5a == 4 ~ 3,
			TRUE ~ as.numeric(Q5a)
		)
	)


dat.psqi  <- dat.psqi %>%
	rowwise() %>%
	mutate(
		Q2and5 = sum(c(Q2score1, Q5aScore1), na.rm = TRUE)
	) %>%
	ungroup()

dat.psqi <- dat.psqi %>% 
	mutate(
		psqi_Comp2 = case_when(
			Q2and5 == 0 ~ 0,
			Q2and5 >= 1 & Q2and5 <= 2 ~ 1,
			Q2and5 >= 3 & Q2and5 <= 4 ~ 2,
			Q2and5 >= 5 & Q2and5 <= 6 ~ 3,
			TRUE ~ as.numeric(Q2and5)
		)
	)

```

```{r ---> COMP 3}
# Component 3: Sleep duration—question 4

dat.psqi$Q4 <- dat.psqi$psqi_4

dat.psqi  <- dat.psqi %>%
	mutate(
		psqi_Comp3 = case_when(
			Q4 > 7 ~ 0,
			Q4 >= 6 & Q4 <= 7 ~ 1,
			Q4 >= 5 & Q4 < 6 ~ 2,
			Q4 < 5 ~ 3,
			TRUE ~ as.numeric(Q4)
		)
	)

dat.psqi <- dat.psqi %>% relocate(Q4, .before = psqi_Comp1)

```

```{r ---> COMP 4}
# Component 4: Sleep efficiency—questions 1, 3, and 4
# Sleep efficiency = (# hours slept/# hours in bed) X 100% 
#	= (Q4 / TIB) * 100
# hours slept—question 4
# hours in bed—calculated from responses to questions 1 and 3
# 	Sleep efficiency, Component score 
# 		> 85%, 0	
# 		75-84%, 1
# 		65-74%, 2
# 		< 65%, 3

dat.psqi$SE <- (dat.psqi$Q4 / dat.psqi$TIB) * 100

dat.psqi  <- dat.psqi %>%
	mutate(
		psqi_Comp4 = case_when(
			SE >= 85 ~ 0,
			SE >= 75 & SE < 85 ~ 1,
			SE >= 65 & SE < 75 ~ 2,
			SE < 65 ~ 3,
			TRUE ~ as.numeric(SE)
		)
	)

dat.psqi <- dat.psqi %>% relocate(SE, .before = psqi_Comp1)
```

```{r ---> COMP 5}
# Sum of 5b to 5j scores, Component 5 score
# 0, 0
# 1-9, 1
# 10-18, 2 
# 19-27, 3

dat.psqi$psqi_5j <- dat.psqi$psqi_5othera # copy variable

#		REARRANGE COLUMNS - AGAIN
dat.psqi <- dat.psqi %>% relocate(psqi_5othera, .before = psqi_5b)
dat.psqi <- dat.psqi %>% relocate(psqi_5b, .before = psqi_Comp1)
dat.psqi <- dat.psqi %>% relocate(psqi_5c, .before = psqi_Comp1)
dat.psqi <- dat.psqi %>% relocate(psqi_5d, .before = psqi_Comp1)
dat.psqi <- dat.psqi %>% relocate(psqi_5e, .before = psqi_Comp1)
dat.psqi <- dat.psqi %>% relocate(psqi_5f, .before = psqi_Comp1)
dat.psqi <- dat.psqi %>% relocate(psqi_5g, .before = psqi_Comp1)
dat.psqi <- dat.psqi %>% relocate(psqi_5h, .before = psqi_Comp1)
dat.psqi <- dat.psqi %>% relocate(psqi_5i, .before = psqi_Comp1)
dat.psqi <- dat.psqi %>% relocate(psqi_5j, .before = psqi_Comp1)


#		RESCORE THE RESPONSES - ORIG = 1-4; NEW = 0-3
#		THIS REPLACES THE VALUES IN THE ORIGINAL VARIABLES
dat.psqi <- dat.psqi %>% 
	mutate_at(vars(matches("psqi_5[b-i]$")), ~ . - 1)

#		RESCORING THE LONG WAY
dat.psqi$Q5b <- dat.psqi$psqi_5b -1
dat.psqi$Q5c <- dat.psqi$psqi_5c -1
dat.psqi$Q5d <- dat.psqi$psqi_5d -1
dat.psqi$Q5e <- dat.psqi$psqi_5e -1
dat.psqi$Q5f <- dat.psqi$psqi_5f -1
dat.psqi$Q5g <- dat.psqi$psqi_5g -1
dat.psqi$Q5h <- dat.psqi$psqi_5h -1
dat.psqi$Q5i <- dat.psqi$psqi_5i -1
dat.psqi$Q5j <- dat.psqi$psqi_5j 

#		SUMMING THE SCORES
dat.psqi  <- dat.psqi %>%
	rowwise() %>%
	mutate(
		Q5s = sum(c(Q5b, Q5c, Q5d, Q5e, Q5f, Q5g, Q5h, Q5i, Q5j), na.rm = TRUE)
	) %>%
	ungroup()


# Sum of 5b to 5j scores, Component 5 score
# 0, 0
# 1-9, 1
# 10-18, 2 
# 19-27, 3
#		CONVERTING TO COMPONENT SCORE
dat.psqi <- dat.psqi %>% 
	mutate(
		psqi_Comp5 = case_when(
			Q5s < 1 ~ 0,
			Q5s >= 1 & Q5s <=9 ~ 1,
			Q5s >= 10 & Q5s <=18 ~ 1,
			Q5s >= 19 & Q5s <=27 ~ 1,
			TRUE ~ as.numeric(Q5s)
		)
	)



dat.psqi <- dat.psqi %>% relocate(psqi_Comp1, .after = last_col())
dat.psqi <- dat.psqi %>% relocate(psqi_Comp2, .after = last_col())
dat.psqi <- dat.psqi %>% relocate(psqi_Comp3, .after = last_col())
dat.psqi <- dat.psqi %>% relocate(psqi_Comp4, .after = last_col())
dat.psqi <- dat.psqi %>% relocate(psqi_Comp5, .after = last_col())




```

```{r ---> COMP 6}
# Component 6: Use of sleep medication—question 6
# Response to Q6, Component 6 score
# Not during past month, 0
# Less than once a week, 1 
# Once or twice a week, 2
# Three or more times a week, 3

dat.psqi$psqi_Comp6 <- as.numeric(dat.psqi$psqi_6)

```

```{r ---> COMP 7}
# 	Component 7: SUM Daytime dysfunction—questions 7 and 8
# Sum of Q7 and Q8 subscores, COMPONENT SCORE 
# 0,0
# 1-2 1 
# 3-4 2 
# 5-6 3

#		SUM QUESTIONS 7 AND 8a
dat.psqi  <- dat.psqi %>%
	rowwise() %>%
	mutate(
		Q7and8a = sum(c(psqi_7, psqi_8a), na.rm = TRUE)
	) %>%
	ungroup()

#		SCORE COMPONENT 7
dat.psqi  <- dat.psqi %>%
	mutate(
		psqi_Comp7 = case_when(
			Q7and8a > 1 ~ 0,
			Q7and8a >= 1 & Q7and8a <= 2 ~ 1,
			Q7and8a >= 3 & Q7and8a <= 4 ~ 2,
			Q7and8a >= 5 & Q7and8a <= 6 ~ 3,
			TRUE ~ as.numeric(Q7and8a)
		)
	)

dat.psqi <- dat.psqi %>% relocate(psqi_Comp1, .after = last_col())
dat.psqi <- dat.psqi %>% relocate(psqi_Comp2, .after = last_col())
dat.psqi <- dat.psqi %>% relocate(psqi_Comp3, .after = last_col())
dat.psqi <- dat.psqi %>% relocate(psqi_Comp4, .after = last_col())
dat.psqi <- dat.psqi %>% relocate(psqi_Comp5, .after = last_col())
dat.psqi <- dat.psqi %>% relocate(psqi_Comp6, .after = last_col())
dat.psqi <- dat.psqi %>% relocate(psqi_Comp7, .after = last_col())

```

```{r ---> GLOBAL Score}
# Global PSQI Score: Sum of seven component scores:

dat.psqi  <- dat.psqi %>%
	rowwise() %>%
	mutate(
		psqi_Global = sum(c(psqi_Comp1, psqi_Comp2, psqi_Comp3,
							psqi_Comp4, psqi_Comp5, psqi_Comp6,
							psqi_Comp7), na.rm = TRUE)
	) %>%
	ungroup()

```

MERGE BACK INTO MAIN DATASET
```{r ---> REINTEGRATE}
#		COMBINING 2 DATASETS

#		CREATING SMALL PSQI DATASET
psqiSM  <- dat.psqi %>% dplyr::select("ID","psqi_Comp1", "psqi_Comp2", "psqi_Comp3",
									  "psqi_Comp4", "psqi_Comp5", "psqi_Comp6",
									  "psqi_Comp7", "psqi_Global")

dat1 <- merge(dat1, psqiSM, by = "ID")

# ls()
```































```{r ---> Small datasets}

#		CREATING SMALL DATASETS
# datSM1  <- dat1 %>% dplyr::select("ID","group.factor","ess_total", "bdi_total", "mcgill_total")
datSM1  <- dat1 %>% dplyr::select("group.factor","ess_total", "bdi_total", "mcgill_total")
datSM1   <- filter(datSM1, ess_total != "NA")


dat.HC <- datSM1 %>% 
	filter(group.factor == "HC")
dat.FM <- datSM1 %>% 
	filter(group.factor == "FM")
dat.CLBP <- datSM1 %>% 
	filter(group.factor == "CLBP")

#		WRITE SMALL DATASET
write_csv(datSM1, "datSM1.csv",
		  na = "NA", append = FALSE,
		  col_names = TRUE, quote_escape = "double")


#		TO RECREATE A DATASET
# dput(head(dat.time, 20))
# dput(datSM1)
#		NOT ALL SUBJECTS HAVE COMPLETE DATA
#		DONE AS OF March 31, 2020
```

##	EXAMINE DATA
```{r ---> Summarize small dataset}
datSM1.smry <- by(datSM1, datSM1$group.factor, summary)

```


```{r ---> Plot ANOVA}
#	TAKEN FROM
# https://www.r-bloggers.com/how-to-do-a-t-test-or-anova-for-many-variables-at-once-in-r-and-communicate-the-results-in-a-better-way/

#		PRESERVE ORIGINAL DATA
dat <- datSM1

# Edit from here
x <- which(names(dat) == "group.factor") # name of grouping variable
y <- which(names(dat) == "ess_total" # names of variables to test
| names(dat) == "bdi_total"
| names(dat) == "mcgill_total")
# | names(dat) == "Petal.Width")
method1 <- "anova" # one of "anova" or "kruskal.test"
method2 <- "t.test" # one of "wilcox.test" or "t.test"
my_comparisons <- list(c("HC", "CLBP"), c("HC", "FM"), c("CLBP", "FM")) # comparisons for post-hoc tests
# Edit until here


# Edit at your own risk
for (i in y) {
  for (j in x) {
    p <- ggboxplot(dat,
      x = colnames(dat[j]), y = colnames(dat[i]),
      color = colnames(dat[j]),
      legend = "none",
      palette = "npg",
      add = "jitter"
    )
    print(
      p + stat_compare_means(aes(label = paste0(..method..,
      										  ", p-value = ", ..p.format..,
      										  " (", ifelse(..p.adj.. > 0.05, 
      										  			 "not significant",
      										  			 ..p.signif..), ")")),
      					   method = method1, 
      					   label.y = max(dat[, i], na.rm = TRUE)
      )
      + stat_compare_means(comparisons = my_comparisons, method = method2, 
      					 hide.ns = FALSE, # JC added
      					 label.sep = ", ",
      					 label = "p.format") # remove if p-value of ANOVA or Kruskal-Wallis test >= 0.05
      )
  }
}

```



```{r ---> Correlations 1, echo=TRUE}

library(tidyverse)
library(psych)

iris.cor <- iris %>%
	# mutate(new.group = sample(LETTERS, 150, replace=TRUE)) %>% 
  split(.$Species) %>%  
  map(~corr.test(x = .x %>% select(Petal.Width, Sepal.Width),
                 use = "everything",
                 method = "spearman",
                 adjust = "none",
                 alpha = 0.05,
                 ci = TRUE, minlength = 5)
  )

print(iris.cor)
iris.cor.r <- map(iris.cor, ~.x$r)
iris.cor.p <- map(iris.cor, ~.x$p)
print(x = iris.cor.r, short = TRUE)
print(x = iris.cor.p, short = TRUE)


gp.cor1 <- datSM1 %>%
  split(datSM1$group.factor) %>%  
  map(~corr.test(datSM1 %>% select(ess_total, bdi_total, mcgill_total),
                 use = "pairwise",
                 method = "spearman",
                 adjust = "none",
                 alpha = 0.05,
                 ci = TRUE, minlength = 5)
  )

print(gp.cor1)

gp.cor1.r <- map(gp.cor1, ~.x$r)
gp.cor1.p <- map(gp.cor1, ~.x$p)
print(x = gp.cor1.r, short = TRUE)
print(x = gp.cor1.p, short = TRUE)


```

```{r ---> Correlations 1a}



# If you want the correlations between all numeric columns and your data has columns that are not numeric, you can exclude the non-numeric columns (which you need to do to avoid an error from corr.test) as follows (where I've used the default corr.test arguments to shorten the code):
# gp.cor <- iris %>%
#   # Add another non-numeric column
#   mutate(new.group = sample(LETTERS, 150, replace=TRUE)) %>% 
#   split(.$Species) %>%  
#   map(~corr.test(x = .x %>% select_if(is.numeric))
#   )

"Use Pairwise and Spearman"
# corr.hc.mtrx <- dat.HC %>%
	
	# map(~
corr.hc.mtrx <- corr.test(dat.HC %>% 
						   select(ess_total, bdi_total, mcgill_total),
						   use = "pairwise", 
						   # available: pairwise, complete
						   method = "spearman", 
						   # available: pearson, spearman, kendall
						   adjust = "none"
						  # available: holm, hochberg, hommel,
						  # bonferroni, BH, BY, fd, none
						   )
print(corr.hc.mtrx, short = TRUE)










corr.hc.mtrx2  <- dat.HC[, c(2:4)]
round(cor(corr.hc.mtrx2), 2)

corr.clbp.mtrx <- corr.test(dat.CLBP %>% 
						   select(ess_total, bdi_total, mcgill_total),
						   use = "pairwise", 
						   # available: pairwise, complete
						   method = "spearman", 
						   # available: pearson, spearman, kendall
						   adjust = "none"
						  # available: holm, hochberg, hommel,
						  # bonferroni, BH, BY, fd, none
						   )
print(corr.clbp.mtrx, short = TRUE)

corr.fm.mtrx <- corr.test(dat.FM %>% 
						   select(ess_total, bdi_total, mcgill_total),
						   use = "pairwise", 
						   # available: pairwise, complete
						   method = "spearman", 
						   # available: pearson, spearman, kendall
						   adjust = "none"
						  # available: holm, hochberg, hommel,
						  # bonferroni, BH, BY, fd, none
						   )
print(corr.fm.mtrx, short = TRUE)





#		TRYING TO TEST THE CORRELATIONS BETWEEN GROUPS
# dat2  <- dat1 %>% dplyr::select("group.factor","ess_total", "bdi_total", "mcgill_total")

gp.cor2 <- datSM1 %>%
	split(datSM1$group.factor) %>%
	map(~corr.test(datSM1 %>% select(ess_total, bdi_total, mcgill_total),
				   use = "pairwise",
				   method = "spearman",
				   adjust = "none",
				   alpha = 0.05,
				   ci = TRUE, minlength = 5)
	)

print(gp.cor2)


gp.cor3 <- datSM1 %>%
	split(datSM1$group.factor) %>%
	map(~corr.test(datSM1 %>% select(ess_total, bdi_total, mcgill_total),
				   use = "pairwise",
				   method = "spearman",
				   adjust = "none",
				   alpha = 0.05,
				   ci = TRUE, minlength = 5)
	)


print(gp.cor3)




cor.mtrx <- cor(dat2[3:5], use = "complete.obs", method = "pearson")
corrplot(cor.mtrx, method = ("number"))


#		CORRELATIONS
"Use Pairwise and Spearman"
cor.bdi.ess <- corr.test(x = dat2[3:4],
						 y = NULL, 
						 use = "pairwise", # available: pairwise, complete
						 method = "spearman",
						 # available: pearson, spearman, kendall
						 adjust = "none",
						 # available: holm, hochberg, hommel, 
						 # bonferroni, BH, BY, fd, none
						 alpha = 0.05,
						 ci = TRUE,minlength = 5
					  )

# gp.cor <- dat2 %>%
# 	group_by(group.factor) %>%
cor.mtrx3 <- 	corr.test(x = dat2[3:4],
			  y = NULL, 
			  use = "everything", # available: pairwise, complete
			  method = "spearman",
			  # available: pearson, spearman, kendall
			  adjust = "none",
			  # available: holm, hochberg, hommel, 
			  # bonferroni, BH, BY, fd, none
			  alpha = 0.05,
			  ci = TRUE,minlength = 5
	)





print(x = cor.mtrx, short = TRUE)
print(x = cor.mtrx, short = FALSE)

cor.mtrx2 <- ezCor(
  data = dat2[,c(3:4)],
  r_size_lims = c(4,4),
  label_size = 3
)
print(cor.mtrx2)
print(cor.mtrx3)


# dat2 %>%
# 	group_by(group.factor) %>%
	
	
# gp.cor <- dat2 %>%
# 	group_by(group.factor) %>%
# 	cor.mtrx3 <- 	corr.test(x = dat2[3:4],
# 							y = NULL,
# 							use = "everything", # available: pairwise, complete
# 							method = "spearman",
# 							# available: pearson, spearman, kendall
# 							adjust = "none",
# 							# available: holm, hochberg, hommel,
# 							# bonferroni, BH, BY, fd, none
# 							alpha = 0.05,
# 							ci = TRUE,minlength = 5
# 	)


# corr.p(corr_matrix,158,adjust = "none",alpha = .05,minlength = 5,ci=TRUE)

#corr_matrix


# 
# t_tests_base <- lapply(
# 	dat1[resp_vars],
# 	function(x) { t.test(x ~ group.factor, data = dat1) }
# 	)
# 
# t_tests_base$disp

```



###	BDI
```{r ---> BDI Summary}
#		BDI VARIABLES
# dat.bdi <- dat1[c(1:2,grep("bdi", colnames(dat1)))]
# view(dat.bdi)

bdi.smry1  <- dat1 %>%
	group_by(group.factor) %>%
	summarise(
		count = n(),
		avg.bdi.tot = mean(bdi_total, na.rm = TRUE),
		sd.bdi.tot = sd(bdi_total, na.rm = TRUE)
		)
view(bdi.smry1)
```

```{r ---> ANOVA BDI}
library(gplots)
#		COMPUTE ANOVA OF BDI 
bdi.aov = aov(bdi_total ~ group.factor, data=dat1)
 print(bdi.aov)

#		SUMMARY OF THE ANALYSES
summary(bdi.aov)
TukeyHSD(bdi.aov)
summary(glht(bdi.aov, linfct = mcp(group.factor = "Tukey")))

pairwise.t.test(dat1$bdi_total, dat1$group.factor,
				p.adjust.method = "BH")

# 	1. Homogeniety of variances
plot(bdi.aov, 1)

 
 library(car)
#	Levene's Test
leveneTest(bdi_total ~ group.factor, data = dat1)

#	Relaxing the homogeneity of variance assumption
oneway.test(bdi_total ~ group.factor, data = dat1)

pairwise.t.test(dat1$bdi_total, dat1$group.factor,
				p.adjust.method = "BH",
				pool.sd = FALSE)

#	2. Normality
# plot(bdi.aov, 2) #	Produces errors

#	EXTRACT RESIDUALS
bdi.aov.resid <- residuals(object = bdi.aov)

#	RUN Shapiro-Wilk normality test
shapiro.test(x = bdi.aov.resid)

#	Non-parametric alternative to one-way ANOVA test
kruskal.test(bdi_total ~ group.factor, data = dat1)

#		DONE AS OF March 17, 2020
```


### BDI & ESS

```{r ---> Correlations 2}
#		FOLLOWING YOOUTUBE VIDEO ABOUT CORRELATIONS
#		Will have to create dummy variables to look 
#		at the correlations of factor variables
dat3 <- dat2
# dat3$group.factor
dat3  <- select(dat2, na.rm = TRUE) 

dat3 %>% count(group.factor)

```

```{r  ---> NEEDS WORK MANOVA}

# url: https://amunategui.github.io/Exploring-Your-Data-Set/

library(caret)
dmy <- dummyVars(" ~ .", data = dat3)

dat3Trsf <- data.frame(predict(dmy, newdata = dat3))

# dat4Trsf <- dat3Trsf

cor.prob <- function(X, dfr = nrow(X) - 2) {
	 R <- cor(X, use = "pairwise.complete.obs")
	 above <- row(R) < col(R)
	 r2 <- R[above]^2
	 Fstat <- r2 * dfr / (1 - r2)
	 R[above] <- 1 - pf(Fstat, 1, dfr)
	 R
}

flattenSquareMatrix <- function(m) {
	if( (class(m) != "matrix") | (nrow(m) != ncol(m))) stop("Must be a square matrix.")
	if(!identical(rownames(m), colnames(m))) stop("Row and column names must be equal.")
	ut <- upper.tri(m)
	data.frame(i = rownames(m)[row(m)[ut]],
			   j = rownames(m)[col(m)[ut]],
			   cor=t(m)[ut],
			   p=m[ut])
}
corMasterlist <- flattenSquareMatrix(cor.prob(dat3Trsf))
dim(corMasterlist)
head(corMasterlist)

corList <- corMasterlist[order(-abs(corMasterlist$cor)),]
print(head(corList))

selectedSub <- subset(corList, (abs(cor) > 0.2 & j == 'mcgill_total'))
print(selectedSub) 

bestSub  <- as.character(selectedSub$i)

library(psych)
pairs.panels(dat3Trsf[c(bestSub, 'mcgill_total')])



#	END
```

```{r ---> Epsworth}
ess.dat  <- dat1[c(1:2,grep("ess", colnames(dat1)))]
view(ess.dat)
```



```{r ---> PSQI}
psqi.dat  <- dat1[c(1:2,grep("psqi", colnames(dat1)))]
view(dat.psqi)

```






```{r ---> ANOVA 2b}
#		COMPUTE ANOVA OF MULTIPLE VARIABLES
# model1 = aov(bdi_total ~ group.factor, data = dat1)
# print(model1)
# 
# #		SUMMARY OF THE ANALYSIS
# summary(model1)
# TukeyHSD(model1)
# library(multcomp)
# 
# summary(glht(model1, linfct = mcp(group.factor = "Tukey")))
# 
# # 	1. Homogeniety of variances
# plot(model1, 1)
# 
# #	Levene's Test
# leveneTest(bdi_total ~ group.factor, data = dat1)
# 
# #	2. Normality
# plot(model1, 2)
# 
# #	EXTRACT RESIDUALS
# aov_residuals  <- residuals(object = model1)
# 
# #	RUN Shapiro-Wilk normality test
# shapiro.test(x = aov_residuals)
# 
# 
# dat1.gp.BDI  <- ggplot(data = dat1.smry1,
# 					   aes(x = group.factor,
# 					   	y = bdi_total,
# 					   	fill = group.factor)) +
# 	geom_bar(color = "black", stat = "identity",
# 			 position = position_dodge(),
# 			 size = .3) +
# 	scale_fill_hue(name = "Groups") +
# 	xlab("Subjects groups") +
# 	ylab("BDI total") +
# 	ggtitle("BDI by group analysis")
# 
# print(dat1.gp.BDI)
# 
# print(dat1.gp.BDI)

# dat1.gp.BDI  <- ggplot(data = dat1,
# 					   aes(x = group.factor,
# 					   	y = bdi_total,
# 					   	fill = group.factor)) +
# 	geom_bar(color = "black", stat = "identity",
# 			 position = position_dodge(),
# 			 size = .3) +
# 	scale_fill_hue(name = "Groups") +
# 	xlab("Subjects groups") +
# 	ylab("BDI total") +
# 	ggtitle("BDI by group analysis")
# 
# print(dat1.gp.BDI)
# 
# dat1.gp.BDI  <- ggplot(data = dat1, na.rm = TRUE,
# 					   aes(x = group.factor,
# 					   	y = bdi_total,
# 					   	fill = group.factor)) +
# 	geom_bar(color = "black", stat = "identity",
# 			 position = position_dodge(),
# 			 size = .3) +
# 	scale_fill_hue(name = "Groups") +
# 	xlab("Subjects groups") +
# 	ylab("BDI total") +
# 	ggtitle("BDI by group analysis")
# print(dat1.gp.BDI)


```











```{r ---> MANOVA}
# data(mtcars)
# head(mtcars)
# help(manova)
# model1 <- manova(cbind(mpg, qsec, wt) ~ cyl * gear * carb, data = mtcars)
# summary(model1)
# model1

#		TRYING THE ABOVE WITH MY OWN DATA
# dat2  <- dat1 %>% dplyr::select("group.factor","ess_total", "bdi_total", "mcgill_total")


gp.manova1 <- manova(cbind(ess_total, bdi_total,
							mcgill_total) ~ group.factor,
					  data = dat2)
summary(gp.manova1)
## Dufferent tests for the MANOVA
summary(gp.manova1, test = "Hotelling-Lawley")
summary(gp.manova1, test = "Roy")
summary(gp.manova1, test = "Pillai")
summary(gp.manova1, test = "Wilks")

## LOOK TO SEE WHICH DIFFER
summary.aov(gp.manova1)




```

```{r ---> BDI Plots}
#		BAR CHART
# bdi.smry2  <- ggplot(data = dat1,
# 					   aes(x = group.factor,
# 					   	y = bdi_total,
# 					   	fill = group.factor)) +
# 	geom_bar(color = "black", stat = "identity",
# 			 position = position_dodge(),
# 			 size = .3) +
# 	scale_fill_hue(name = "Groups") +
# 	xlab("Subjects groups") +
# 	ylab("BDI total") +
# 	ggtitle("BDI by group")
# 
# print(bdi.smry2) # I'm not sure what values are used in the graph
# 
# #		BOX PLOT
# ggplot(data = dat1, mapping = aes(x = group.factor, y = bdi_total)) +
# 	geom_boxplot()
# 
# 
# ggboxplot(dat1, x = "group", y = "bdi_total",
# 		  add = "dotplot")
# 
# ggboxplot(dat1, x = "group.factor", y = "bdi_total",
# 		  add = "jitter", shape = "group.factor")
# 
# ggboxplot(dat1, x = "group.factor", y = "bdi_total",
# 		  order = c("FM", "CLBP", "HC"))
# 
# ggboxplot(dat1, x = "group.factor", y = "bdi_total",
# 		  color = "red", fill = "darkblue",
# 		  order = c("FM", "CLBP", "HC"))
# 


# Mean plots
# ++++++++++++++++++++
# Plot weight by group
# Add error bars: mean_se
# (other values include: mean_sd, mean_ci, median_iqr, ....)
# ggline(dat1, x = "group.factor", y = "bdi_total", 
#        add = c("mean_se", "jitter"), 
#        order = c("FM", "CLBP", "HC"),
#        ylab = "BDI Total", xlab = "Group")


# Box plots - 	NOTY WORKING
# ++++++++++++++++++++
# Plot BDI by group and color by group
# bp <- ggboxplot(data = dat1, mapping = aes(x = group.factor, y = bdi_total, 
# 										 fill = group.factor)) +
# 	geom_boxplot()

	
# 		  color = "black", fill = 
# 		  order = c("HC", "CLBP", "FM"),
#           ylab = "BDI", xlab = "Group")

# dat.totals <- dat1[c(1:2,grep("_total", colnames(dat1)))]
# view(dat.totals)

#		DONE AS OF March 17, 2020
```

```{r ---> line plot}
ggline(dat1, x = "group.factor", y = "bdi_total", 
       add = c("mean_se", "jitter"),
       order = c("FM", "CLBP", "HC"),
       ylab = "BDI Total", xlab = "Group")

```





##		PLOTS
```{R ---> Bar chart by Group}
# dat1.gp.BDI  <- ggplot(data = dat1,
# 						aes(x = group.factor,
# 							y = bdi_total, pdi_total,
# 							fill = group.factor)) +
# 	geom_bar(color = "black", stat = "identity",
# 			 position = position_dodge(),
# 			 size = .3) +
# 	scale_fill_hue(name = "group") +
# 	xlab("Subjects groups") +
# 	ylab("BDI total") +
# 	ggtitle("BDI by group analysis")
# 
# print(dat1.gp.BDI)

```


```{r ---> Box plots}
# ggplot(data = dat1, mapping = aes(x = group.factor, y = bdi_total)) +
# 	geom_boxplot()
# 
# ggplot(data = dat1) +
# 	geom_boxplot(mapping = aes(x = reorder(group.factor, bdi_total, FUN = median), y = bdi_total))
# 

```


##	SCRAP
```{r ---> Scrap}

# data <- read_csv('ImagingPsychometrics-BradPTConference_R_2020-03-16_1300.r', col_names = TRUE)

# spec_csv("ImagingPsychometrics-BradPTConference_R_2020-03-16_1300.r")

# " col_names = TRUE)


datSM2 %>% count(group.factor)
mean(datSM2$ess_total)
datSM2 %>% count(ess_total)


# summarise(datSM2,
# 		  maxESS = max(ess_total, na.rm = TRUE),
# 		  avgESS = mean(ess_total, na.rm = TRUE)
# )













# smallData <- select(dat1, ID, group.factor, bdi_total)
# 
# write_csv(smallData,
# 		  '/Users/jcraggs/Documents/GitHub/Brad_PT/smData_v1.csv',
# 		  na = "NA", append = FALSE,
# 		  col_names = TRUE, quote_escape = "double")	
#		I TRIED THIS TO REARRANGE THE VARIABLES BUT IT ISN'T WORKING RIGHT NOW
# dat2 <- arrange(dat1, ID, group.factor, sex)
# arrange(dat2, ID, group.factor, sex)

#	RENAME VARIABLES
# df = dataframe
# old.var.name = The name you don't like anymore
# new.var.name = The name you want to get



# dat.full <- read_tsv("ImagingPsychometrics-BradPTConference_R_2020-03-16_1300.r")
# dat.full.may <- read.csv("ImagingPsychometrics_DATA_2017-05-25_1010.csv", header = TRUE)
#	THIS WORKS AS OF March 15, 2020
#a1_Ctr3_voi1_2020_03_12_for_R <- read_tsv("~/Box Sync/Lab/Societies/APS/2017/APS2017_NeuroElf/Ctr3_voi1_2020_03_12_for_R.txt", col_names = TRUE)

#a2_SubjectList_2020_03_12 <- read_tsv("~/Box Sync/Lab/Societies/APS/2017/APS2017_NeuroElf/SubjectList_2020_03_12.txt", col_names = TRUE


##  bdi_total

# dat.pdi  <- data[c(1:2,grep("pdi", colnames(data)))]
# 
# dat.pain  <- data[c(1:2,grep("pain", colnames(data)))]
# 
# 


# dat.bdi2  <- select(dat.bdi,
# 					ends_with(!= "factor"))




# {r ---> Jon: creating new variables}
# This works
# library(dplyr)
# data1 %>% 
#   mutate_at(
#     vars(starts_with("pos"), starts_with("neg")),
#     ~as.numeric(as.character(.))
#   ) %>% 
#   rowwise() %>% 
#   mutate(
#     testAvg1 = mean(c(pos_pre1_DMN, pos_pre2_DMN), na.rm = TRUE)
#   ) %>% 
#   ungroup()

```




```{r ---> Factors}
# dat.factors  <- select_if(dat1, is.factor)
# colnames(dat.factors)

# levels(dat.factors$condition.factor)
# 
# class(dat1$group.factor)
# levels(dat1$group.factor)
# #		DONE AS OF March 17, 2020

```




```{r ---> skimr}

skimr::skim(datSM1)

```


















